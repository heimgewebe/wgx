### ðŸ“„ .github/workflows/ci.yml

**GrÃ¶ÃŸe:** 14 KB | **md5:** `4ef54d52ced4b0ae03e0147dd359be5b`

```yaml
name: CI (smart PR)

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  merge_group: {}
  workflow_dispatch: {}

permissions:
  id-token: write
  pull-requests: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      shell: ${{ steps.filter.outputs.shell }}
      tests: ${{ steps.filter.outputs.tests }}
      docs: ${{ steps.filter.outputs.docs }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            shell:
              - 'wgx'
              - '**/*.sh'
              - '**/*.bash'
            tests:
              - 'tests/**/*.bats'
              - 'tests/**/*.sh'
            docs:
              - '**/*.md'
              - 'docs/**'

  lint_shell:
    name: Shell lint (shfmt + shellcheck)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.shell == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci') ||
          contains(github.event.pull_request.labels.*.name, 'lint')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Find changed shell files
        id: shell_files
        env:
          FORCE_FULL: ${{ github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'full-ci') || contains(github.event.pull_request.labels.*.name, 'lint') }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
        run: |
          set -euo pipefail
          base="$PR_BASE_SHA"
          head="${GITHUB_SHA}"
          declare -a candidates=()
          if [[ "$FORCE_FULL" == 'true' ]]; then
            mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
          elif [[ -n "$base" ]]; then
            if git fetch --no-tags --depth=50 origin "$base"; then
              mapfile -t candidates < <(git diff --name-only "$base" "$head" 2>/dev/null || true)
            else
              echo "git fetch failed; falling back to full shell file list" >&2
              mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
            fi
          else
            mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
          fi

          declare -a shell_files=()
          for file in "${candidates[@]}"; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              case "$file" in
                *.sh|*.bash|wgx)
                  shell_files+=("$file")
                  ;;
              esac
            fi
          done

          {
            echo 'files<<EOF'
            printf '%s\n' "${shell_files[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - name: Install shell tooling
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends shellcheck shfmt jq
      - name: bash -n (syntax check)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh --per-file "No shell files to check." bash -n <<'EOF'
${{ steps.shell_files.outputs.files }}
EOF
      - name: shfmt (check)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No shell files to format." shfmt -d <<'EOF'
${{ steps.shell_files.outputs.files }}
EOF
      - name: shellcheck
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No shell files to lint." shellcheck -S style <<'EOF'
${{ steps.shell_files.outputs.files }}
EOF

  bats_tests:
    name: Bats tests
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.shell == 'true' ||
          needs.changes.outputs.tests == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci') ||
          contains(github.event.pull_request.labels.*.name, 'tests') ||
          contains(github.event.pull_request.labels.*.name, 'bats')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Run bats test suites
        # Pin to v1.8.0, the latest published release of bats-core/bats-action.
        uses: bats-core/bats-action@v1.8.0
        with:
          helpers: |
            bats-support
            bats-assert

  docs_lint:
    name: Docs lint (Markdown + Links)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        (
          needs.changes.outputs.docs == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Find changed docs and script files
        id: changed_docs
        env:
          FORCE_FULL: ${{ github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'full-ci') }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
        run: |
          set -euo pipefail
          base="$PR_BASE_SHA"
          head="${GITHUB_SHA}"
          declare -a candidates=()
          if [[ "$FORCE_FULL" == 'true' ]]; then
            mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
          elif [[ -n "$base" ]]; then
            if git fetch --no-tags --depth=50 origin "$base"; then
              mapfile -t candidates < <(git diff --name-only "$base" "$head" -- '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
            else
              echo "git fetch failed; falling back to full docs file list" >&2
              mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
            fi
          else
            mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
          fi

          declare -a markdown_files=()
          declare -a vale_files=()
          for file in "${candidates[@]}"; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              case "$file" in
                *.md|*.mdx)
                  markdown_files+=("$file")
                  vale_files+=("$file")
                  ;;
                *.sh|*.bash)
                  vale_files+=("$file")
                  ;;
              esac
            fi
          done

          {
            echo 'markdown_files<<EOF'
            printf '%s\n' "${markdown_files[@]}"
            echo 'EOF'
            echo 'vale_files<<EOF'
            printf '%s\n' "${vale_files[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install Vale
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALE_VERSION: latest
        run: |
          set -euo pipefail
          owner="errata-ai"
          repo="vale"
          version="${VALE_VERSION:-latest}"
          release_json=""

          # Use authenticated GitHub API requests to avoid low rate limits
          accept_header="Accept: application/vnd.github+json"
          api_ver_header="X-GitHub-Api-Version: 2022-11-28"

          curl_headers=(
            -H "$accept_header"
            -H "$api_ver_header"
          )

          if [[ -n "${GITHUB_TOKEN:-}" ]]; then
            curl_headers+=(
              -H "Authorization: Bearer ${GITHUB_TOKEN}"
            )
          fi

          if [[ -n "${version}" && "${version}" != "latest" ]]; then
            if ! release_json=$(curl --retry 5 --retry-all-errors -fsSL \
              "${curl_headers[@]}" \
              "https://api.github.com/repos/${owner}/${repo}/releases/tags/${version}"); then
              echo "Unable to fetch release metadata for ${version}; falling back to the latest release" >&2
              release_json=""
            fi
          fi

          if [[ -z "${release_json}" ]]; then
            release_json=$(curl --retry 5 --retry-all-errors -fsSL \
              "${curl_headers[@]}" \
              "https://api.github.com/repos/${owner}/${repo}/releases/latest")
            version=$(printf '%s' "${release_json}" | python3 - <<'PY'
import json, sys
data = json.load(sys.stdin)
tag = data.get('tag_name')
if not tag:
    raise SystemExit('Latest release tag_name not found')
print(tag)
PY
)
          fi

          if [[ -z "${release_json}" ]]; then
            echo "Failed to retrieve release metadata for Vale" >&2
            exit 1
          fi

          readarray -t asset_info < <(printf '%s' "${release_json}" | python3 - <<'PY'
import json, sys

data = json.load(sys.stdin)
preferred_suffixes = (
    'Linux_64-bit.tar.gz',
    'Linux_amd64.tar.gz',
)

for suffix in preferred_suffixes:
    for asset in data.get('assets', []):
        name = asset.get('name') or ''
        if name.endswith(suffix):
            print(name)
            print(asset.get('browser_download_url') or '')
            sys.exit(0)

raise SystemExit('No suitable Linux tarball found in release assets')
PY
)

          if [[ "${#asset_info[@]}" -lt 2 ]]; then
            echo "Failed to determine Vale asset download information" >&2
            exit 1
          fi

          asset_name="${asset_info[0]}"
          asset_url="${asset_info[1]}"

          checksums_url=$(printf '%s' "${release_json}" | python3 - <<'PY'
import json, sys

data = json.load(sys.stdin)
for asset in data.get('assets', []):
    name = asset.get('name') or ''
    if name.endswith('checksums.txt'):
        print(asset.get('browser_download_url') or '')
        sys.exit(0)

raise SystemExit('checksums.txt not found in release assets')
PY
)

          curl --retry 5 --retry-all-errors -fsSL "${asset_url}" -o vale.tar.gz
          curl --retry 5 --retry-all-errors -fsSL "${checksums_url}" -o checksums.txt

          EXPECTED_SHA256=$(awk -v file="${asset_name}" '$2 == file {print $1; exit}' checksums.txt)
          if [[ -z "${EXPECTED_SHA256:-}" ]]; then
            echo "Unable to determine expected checksum for ${asset_name}" >&2
            exit 1
          fi

          ACTUAL_SHA256=$(sha256sum vale.tar.gz | awk '{print $1}')
          if [[ "${EXPECTED_SHA256}" != "${ACTUAL_SHA256}" ]]; then
            echo "SHA256 checksum mismatch for vale.tar.gz" >&2
            echo "Expected: ${EXPECTED_SHA256}" >&2
            echo "Actual:   ${ACTUAL_SHA256}" >&2
            exit 1
          fi

          tar -xzf vale.tar.gz
          test -f vale && echo "vale binary extracted" || (echo "vale missing" && exit 1)
          sudo install -m 0755 vale /usr/local/bin/vale
          echo "Installed Vale ${version} (${asset_name})"
          vale --version
          rm -f vale vale.tar.gz checksums.txt
      - name: Markdownlint (changed only)
        run: |
          set -euo pipefail
          npm i -g markdownlint-cli2@0.12.1
          ./etc/ci/run-with-files.sh "No Markdown files to lint." markdownlint-cli2 <<'EOF'
${{ steps.changed_docs.outputs.markdown_files }}
EOF
      - name: Vale lint (changed only)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No files for Vale." vale --minAlertLevel=warning <<'EOF'
${{ steps.changed_docs.outputs.vale_files }}
EOF
      - name: Link check (Lychee)
        if: steps.changed_docs.outputs.markdown_files != ''
        uses: lycheeverse/lychee-action@v2
        with:
          args: >-
            --no-progress
            --accept 200,206,429
            --max-concurrency 8
            --retry-wait-time 2
            --timeout 30
            --max-retries 2
            --exclude-path 'node_modules|.git'
            --exclude 'localhost|127\.0\.0\.1|badge\.fury\.io|shields\.io'
            ${{ steps.changed_docs.outputs.markdown_files }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  profile_contracts:
    name: Profile contracts
    needs: changes
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'merge_group' ||
      (
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'full-ci')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        repo:
          - https://github.com/heimgewebe/weltgewebe
          - https://github.com/heimgewebe/hausKI
          # ggf. weitere Repos ergÃ¤nzen
    steps:
      - uses: actions/checkout@v4
      - name: Configure git safe.directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"
      - name: Validate ${{ matrix.repo }}
        env:
          GIT_ASKPASS: /bin/true
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="${{ matrix.repo }}"
          name="${repo##*/}"
          target="$repo"
          if [[ "$repo" == https://github.com/* && -n "${GH_TOKEN:-}" ]]; then
            target="https://x-access-token:${GH_TOKEN}@github.com/${repo#https://github.com/}"
          fi
          ./wgx validate --json "$target" --out "validate_${name}.json"
      - name: Upload JSON results
        uses: actions/upload-artifact@v4
        with:
          name: profile-contracts-json
          path: validate_*.json
```

### ðŸ“„ .github/workflows/cli-docs-check.yml

**GrÃ¶ÃŸe:** 1 KB | **md5:** `1c037b9a35830445f9f6d9b80bdab75e`

```yaml
name: CLI Docs (consistency)

on:
  pull_request:
    branches: [ "**" ]
    paths:
      - "wgx"
      - "cmd/**"
      - "scripts/gen-cli-docs.sh"
      - "docs/cli.md"
  push:
    branches: [ "main" ]
    paths:
      - "wgx"
      - "cmd/**"
      - "scripts/gen-cli-docs.sh"
      - "docs/cli.md"

permissions:
  contents: read
  # keine artifacts, kein cache -> keine actions:write nÃ¶tig

defaults:
  run:
    shell: bash

jobs:
  check:
    name: Regenerate & verify docs/cli.md
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Make generator executable (defensiv)
        run: |
          chmod +x scripts/gen-cli-docs.sh || true
          chmod +x wgx || true

      - name: Regenerate CLI docs
        run: |
          scripts/gen-cli-docs.sh

      - name: Verify no diff
        run: |
          set -euo pipefail
          if git diff --quiet -- docs/cli.md; then
            echo "âœ… docs/cli.md ist aktuell."
          else
            echo "::error::CLI-Referenz ist nicht aktuell. Bitte lokal 'scripts/gen-cli-docs.sh' ausfÃ¼hren und Ã„nderungen committen."
            echo ""
            echo "â”€â”€â”€â”€ git diff docs/cli.md â”€â”€â”€â”€"
            git --no-pager diff -- docs/cli.md || true
            echo ""
            echo "Lokal fixen: ./scripts/gen-cli-docs.sh && git add docs/cli.md && git commit"
            exit 1
          fi
```

### ðŸ“„ .github/workflows/compat-on-demand.yml

**GrÃ¶ÃŸe:** 3 KB | **md5:** `40cd193211e4c2e8c9b4e1f00e85594b`

```yaml
name: Compat (on-demand matrix)

on:
  workflow_dispatch:
    inputs:
      targets_json:
        description: 'Matrix als JSON (repo/ref)'
        required: false
        default: |
          [
            {"repo":"heimgewebe/hausKI","ref":"main"},
            {"repo":"heimgewebe/weltgewebe","ref":"main"}
          ]
  pull_request:
    branches: [ main ]
    types: [labeled, unlabeled, synchronize, reopened, ready_for_review]
  merge_group: {}

permissions:
  id-token: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  gate:
    name: Decide when to run
    runs-on: ubuntu-latest
    outputs:
      run_compat: ${{ steps.decide.outputs.run_compat }}
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            core:
              - 'wgx'
              - 'lib/**'
              - 'modules/**'
              - 'cmd/**'
              - '.github/actions/**'
      - id: decide
        shell: bash
        run: |
          labels="${{ github.event.pull_request.number && join(github.event.pull_request.labels.*.name, ' ') || '' }}"
          # Run if: merge_group OR manual dispatch OR label 'compat'/'full-ci' OR core changed
          if [[ "${{ github.event_name }}" == "merge_group" ]]; then echo "run_compat=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then echo "run_compat=true" >> $GITHUB_OUTPUT
          elif echo "$labels" | grep -qiE '(^| )(compat|full-ci)( |$)'; then echo "run_compat=true" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.filter.outputs.core }}" == "true" ]]; then echo "run_compat=true" >> $GITHUB_OUTPUT
          else echo "run_compat=false" >> $GITHUB_OUTPUT; fi
      - id: matrix
        shell: bash
        run: |
          def='[{"repo":"heimgewebe/hausKI","ref":"main"},{"repo":"heimgewebe/weltgewebe","ref":"main"}]'
          inp=$(cat <<'JSON'
${{ github.event.inputs.targets_json }}
JSON
)
          # Fallback auf Default, wenn Input leer/ungÃ¼ltig
          if jq -e type >/dev/null 2>&1 <<<"$inp"; then echo "matrix=$inp" >> $GITHUB_OUTPUT
          else echo "matrix=$def" >> $GITHUB_OUTPUT; fi

  compat:
    name: Check ${{ matrix.target.repo }}@${{ matrix.target.ref }}
    needs: gate
    if: needs.gate.outputs.run_compat == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix:
        target: ${{ fromJSON(needs.gate.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      - name: Run wgx-check
        uses: ./.github/actions/wgx-check
        with:
          repo: ${{ matrix.target.repo }}
          ref:  ${{ matrix.target.ref }}
```

### ðŸ“„ .github/workflows/contracts.yml

**GrÃ¶ÃŸe:** 214 B | **md5:** `af5c8714385a70cf9e572300c47c980b`

```yaml
name: contracts-validate
permissions:
  contents: read
  actions: read
  checks: write
on: [push, pull_request]
jobs:
  validate:
    uses: heimgewebe/metarepo/.github/workflows/contracts-validate.yml@contracts-v1
```

### ðŸ“„ .github/workflows/metrics.yml

**GrÃ¶ÃŸe:** 1 KB | **md5:** `78cc3152807fabe417ca9a2db0bcb236`

```yaml
name: "ðŸ“Š Metrics Snapshot & Validation"
permissions:
  contents: read
  actions: write
  checks: write
on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *"

env:
  METRICS_SCHEMA_URL: https://raw.githubusercontent.com/heimgewebe/metarepo/contracts-v1/contracts/wgx/metrics.json
  HAUSKI_POST_URL: ${{ secrets.HAUSKI_METRICS_URL }}

jobs:
  snapshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure Node for ajv-cli
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          # Kein npm-Cache am Repo-Root, da es hier keine package-lock.json gibt.
          # Der Cache wÃ¼rde ohne Lockfile fehlschlagen. Daher bewusst deaktiviert.

      - name: Snapshot metrics
        run: scripts/wgx-metrics-snapshot.sh --json

      - name: Validate metrics contract
        run: npx --yes ajv-cli@5 validate -s "$METRICS_SCHEMA_URL" -d metrics.json

      - name: Optional POST to hausKI
        if: ${{ env.HAUSKI_POST_URL && env.HAUSKI_POST_URL != '' }}
        run: |
          curl --fail --silent --show-error \
            -H 'Content-Type: application/json' \
            --data @metrics.json \
            "$HAUSKI_POST_URL"
      - name: Upload metrics.json artifact
        uses: actions/upload-artifact@v4
        with:
          name: metrics-snapshot
          path: metrics.json
```

### ðŸ“„ .github/workflows/release.yml

**GrÃ¶ÃŸe:** 398 B | **md5:** `b0d8769d5d6ff723a14e449e6f7df991`

```yaml
name: release
permissions:
  contents: write
on:
  push:
    tags:
      - 'v*.*.*'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
```

### ðŸ“„ .github/workflows/security.yml

**GrÃ¶ÃŸe:** 2 KB | **md5:** `78af57d27d34d01bed588d85499b69f7`

```yaml
name: security
permissions:
  id-token: write
  contents: read

on:
  schedule:
    - cron: '0 5 * * *'
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:

jobs:
  audit:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: security-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Locate Cargo manifest
        id: cargo-manifest
        run: |
          manifest=$(find . -name Cargo.toml -print -quit)
          if [[ -z "$manifest" ]]; then
            echo "found=false" >>"$GITHUB_OUTPUT"
            echo "No Cargo.toml found â€“ skipping cargo audit run."
          else
            echo "found=true" >>"$GITHUB_OUTPUT"
            echo "manifest=$manifest" >>"$GITHUB_OUTPUT"
          fi
        shell: bash

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      # Caches beschleunigen cargo-audit merklich
      - name: Cache cargo registry + advisory DB
        if: steps.cargo-manifest.outputs.found == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/advisory-db
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install cargo-audit
        if: steps.cargo-manifest.outputs.found == 'true'
        run: cargo install cargo-audit --locked

      - name: Audit dependencies
        if: steps.cargo-manifest.outputs.found == 'true'
        run: cargo audit --manifest-path "${{ steps.cargo-manifest.outputs.manifest }}"
        timeout-minutes: 5

      - name: Skip audit (no Cargo manifest found)
        if: steps.cargo-manifest.outputs.found != 'true'
        run: echo "No Cargo.toml detected in repository; cargo audit skipped."
      # Optional: falls du ein eigenes DB-Verzeichnis nutzt
      # - name: Audit with explicit DB path
      #   run: cargo audit -d ~/.cargo/advisory-db
```

### ðŸ“„ .github/workflows/shell-docs.yml

**GrÃ¶ÃŸe:** 3 KB | **md5:** `6bbd2b306723caa72177206a56b19045`

```yaml
name: shell-docs
permissions:
  contents: read
  actions: write
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  actions: write

jobs:
  shell-and-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node (cache npm)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install deps
        run: |
          export DEBIAN_FRONTEND=noninteractive
          sudo apt-get -yq update
          sudo apt-get -yq install shellcheck shfmt bats
          npm install -g markdownlint-cli@0.43.0
          tmpdir="$(mktemp -d)"
          curl -Ls https://github.com/errata-ai/vale/releases/download/v3.8.0/vale_3.8.0_Linux_64-bit.tar.gz \
            | tar xz -C "$tmpdir"
          sudo mv "$tmpdir/vale" /usr/local/bin/vale
          rm -rf "$tmpdir"
          vale --version
      - name: Lint shells
        run: |
          set -euo pipefail
          mapfile -t files < <(git ls-files '*.sh' '*.bash')
          if [[ ${#files[@]} -eq 0 ]]; then
            echo "No shell files found."
            exit 0
          fi
          bash -n "${files[@]}"
          shfmt -d "${files[@]}"
          shellcheck -S style "${files[@]}"
      - name: Test (bats)
        run: |
          if [ -d tests ]; then
            bats -r tests
          else
            echo "No tests directory" && exit 0
          fi
      - name: Lint markdown
        run: |
          set -euo pipefail
          mapfile -t md_files < <(git ls-files '*.md' '*.mdx')
          if [[ ${#md_files[@]} -eq 0 ]]; then
            echo "No markdown files."
            exit 0
          fi
          markdownlint "${md_files[@]}"
          vale .

  python-uv:
    runs-on: ubuntu-latest
    if: ${{ hashFiles('uv.lock') != '' && hashFiles('**/pyproject.toml') != '' }}
    steps:
      - uses: actions/checkout@v4
      - name: Install uv
        run: |
          set -euo pipefail
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >>"$GITHUB_PATH"
          uv_version="$($HOME/.local/bin/uv --version | awk '{print $2}')"
          echo "UV_VERSION=$uv_version" >>"$GITHUB_ENV"
      - name: Cache uv
        uses: actions/cache@v4
        with:
          path: ~/.cache/uv
          key: uv-${{ runner.os }}-${{ env.UV_VERSION || 'latest' }}-${{ hashFiles('**/pyproject.toml', '**/uv.lock') }}
      - name: Sync deps (frozen)
        run: ~/.local/bin/uv sync --frozen
      - name: Smoke run
        run: ~/.local/bin/uv run python -c "print('uv ok')"
```

### ðŸ“„ .github/workflows/tests-on-demand.yml

**GrÃ¶ÃŸe:** 2 KB | **md5:** `b3f339ddf384650082fe216b2f25121c`

```yaml
name: Tests (bats on-demand)

on:
  workflow_dispatch: {}
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  merge_group: {}

permissions:
  id-token: write
  contents: read
  pull-requests: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.run_id || github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      shell: ${{ steps.filter.outputs.shell }}
      tests: ${{ steps.filter.outputs.tests }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            shell:
              - 'wgx'
              - '**/*.sh'
              - '**/*.bash'
            tests:
              - 'tests/**'
              - '.github/actions/**'
              - '.github/workflows/**'

  bats:
    name: Tests (bats -r tests)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.tests == 'true' ||
          needs.changes.outputs.shell == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'tests') ||
          contains(github.event.pull_request.labels.*.name, 'bats') ||
          contains(github.event.pull_request.labels.*.name, 'full-ci')
        )
      )
    runs-on: ubuntu-latest
    # Bail out proactively if the bats suite stops making progress.
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - name: Run bats tests
        uses: ./.github/actions/run-bats
```

### ðŸ“„ .github/workflows/wgx-guard.yml

**GrÃ¶ÃŸe:** 9 KB | **md5:** `60b7c781f6f56436c1ed579e323456c5`

```yaml
name: wgx-guard
permissions:
  id-token: write
  contents: read
on:
  push:
    paths:
      - ".wgx/**"
      - ".wgx/profile.example.yml"
      - ".github/workflows/**"
      - "pyproject.toml"
      - "uv.lock"
      - "Cargo.toml"
  pull_request:
    paths:
      - ".wgx/**"
      - ".wgx/profile.example.yml"
      - ".github/workflows/**"
      - "pyproject.toml"
      - "uv.lock"
      - "Cargo.toml"
  workflow_dispatch:
  
jobs:
  guard:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: wgx-guard-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Ensure bash is available
        id: ensure-bash
        shell: sh
        run: |
          set -eu
          if (set -o pipefail) 2>/dev/null; then
            set -o pipefail
          fi
          if ! command -v bash >/dev/null 2>&1; then
            echo "::notice::bash not found â€“ attempting installation"
            if [ -f /etc/os-release ]; then
              . /etc/os-release
              case "$ID" in
                alpine)
                  if command -v apk >/dev/null 2>&1; then
                    apk add --no-cache bash || true
                  fi
                  ;;
                debian|ubuntu)
                  if command -v apt-get >/dev/null 2>&1; then
                    apt-get update
                    apt-get install -y bash || true
                  fi
                  ;;
                fedora|rhel|centos)
                  if command -v yum >/dev/null 2>&1; then
                    yum install -y bash || true
                  elif command -v dnf >/dev/null 2>&1; then
                    dnf install -y bash || true
                  fi
                  ;;
              esac
            elif command -v brew >/dev/null 2>&1; then
              brew install bash || true
            fi
          fi
          if command -v bash >/dev/null 2>&1; then
            bash -lc 'set -euo pipefail; bash --version'
            echo "has-bash=true" >>"$GITHUB_OUTPUT"
          else
            echo "::warning::bash not available on this runner. Shell-dependent steps will be skipped."
            echo "has-bash=false" >>"$GITHUB_OUTPUT"
          fi

      - name: Repo smoke (ultra-fast)
        shell: sh
        run: |
          set -eu
          if (set -o pipefail) 2>/dev/null; then
            set -o pipefail
          fi
          echo "ref=${{ github.ref }} sha=${{ github.sha }}"
          test -s README.md || echo "::warning::README.md missing or empty"
          if [ -f Cargo.toml ]; then
            if command -v cargo >/dev/null 2>&1; then
              cargo metadata --no-deps >/dev/null
            else
              echo "::notice::Cargo.toml present but 'cargo' not found â€“ skipping Rust smoke"
            fi
          fi
          if [ -f pyproject.toml ]; then
            grep -q '^[[:space:]]*\[project\]' pyproject.toml || echo "::warning::[project] section not found in pyproject.toml"
          fi

      - name: Generate Readiness
        if: steps.ensure-bash.outputs.has-bash == 'true'
        id: readiness
        shell: bash
        run: |
          set -euo pipefail
          if scripts/gen-readiness.sh; then
            if [ -s artifacts/readiness.json ]; then
              echo "has-matrix=true" >>"$GITHUB_OUTPUT"
            else
              echo "::warning::Readiness artifacts not created"
              echo "has-matrix=false" >>"$GITHUB_OUTPUT"
            fi
          else
            echo "::warning::Readiness generation failed"
            echo "has-matrix=false" >>"$GITHUB_OUTPUT"
          fi

      - name: Upload Readiness artifacts
        if: steps.readiness.outputs.has-matrix == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: readiness-matrix
          retention-days: 7
          path: |
            artifacts/readiness.json
            artifacts/readiness-table.md
            artifacts/readiness-badge.svg

      - name: Check tracked .wgx profile presence (no fallbacks)
        shell: sh
        run: |
          set -eu
          (set -o pipefail) 2>/dev/null && set -o pipefail || true
          if [ "${WGX_ALLOW_NO_PROFILE:-}" = "1" ]; then
            echo "::warning::Skipping profile check due to WGX_ALLOW_NO_PROFILE=1"
            exit 0
          fi
          if files="$(git ls-files -- .wgx/profile.yml .wgx/profile.example.yml)"; then
            if [ -n "$files" ]; then
              echo "OK: tracked wgx profile(s):"
              printf '%s\n' "$files"
              exit 0
            fi
          fi
          echo "::error::No tracked wgx profile found. Commit one of:"
          echo "::error::  â€¢ .wgx/profile.yml   (preferred for production config)"
          echo "::error::  â€¢ .wgx/profile.example.yml   (placeholder for CI)"
          echo
          echo "If you intended to use the example, run:"
          echo "  git add .wgx/profile.example.yml && git commit -m 'Add example profile for CI'"
          echo
          echo "If you have a local .wgx/profile.yml but it's ignored, remove it from .gitignore or commit the example file instead."
          echo "See README.md section '.wgx/profile (v1 / v1.1)' for details."
          exit 1

      - name: Install shellcheck (cached)
        if: steps.ensure-bash.outputs.has-bash == 'true'
        uses: taiki-e/install-action@v2
        with:
          tool: shellcheck

      - name: Install shfmt (cached)
        if: steps.ensure-bash.outputs.has-bash == 'true'
        uses: taiki-e/install-action@v2
        with:
          tool: shfmt

      - name: Shell Lint
        if: steps.ensure-bash.outputs.has-bash == 'true'
        run: |
          set -euo pipefail
          mapfile -t scripts < <(git ls-files '*.sh' '*.bash')
          if [ "${#scripts[@]}" -eq 0 ]; then
            echo "No shell scripts found; skipping lint."
            exit 0
          fi
          bash -n "${scripts[@]}"
          shfmt -d "${scripts[@]}"
          shellcheck -S style "${scripts[@]}"

      - name: Detect Python project
        id: python-project
        shell: sh
        run: |
          if [ -f pyproject.toml ]; then
            echo "present=true" >>"$GITHUB_OUTPUT"
          else
            echo "present=false" >>"$GITHUB_OUTPUT"
          fi

      - name: Install uv
        if: steps.python-project.outputs.present == 'true'
        shell: sh
        run: |
          set -eu
          if (set -o pipefail) 2>/dev/null; then
            set -o pipefail
          fi
          curl -LsSf https://astral.sh/uv/install.sh | sh
          # GitHub Actions schreibt $GITHUB_PATH erst fÃ¼r nachfolgende Schritte um,
          # daher ergÃ¤nzen wir den PATH zusÃ¤tzlich fÃ¼r die aktuelle Shell.
          export PATH="$HOME/.local/bin:$PATH"
          echo "$HOME/.local/bin" >>"$GITHUB_PATH"
          uv_version="$($HOME/.local/bin/uv --version | awk '{print $2}')"
          echo "UV_VERSION=$uv_version" >>"$GITHUB_ENV"

      - name: Cache uv
        if: steps.python-project.outputs.present == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cache/uv
          key: uv-${{ runner.os }}-${{ env.UV_VERSION || 'latest' }}-${{ hashFiles('**/pyproject.toml', '**/uv.lock') }}

      - name: Sync deps (uv)
        if: steps.python-project.outputs.present == 'true'
        shell: sh
        run: |
          set -eu
          if (set -o pipefail) 2>/dev/null; then
            set -o pipefail
          fi
          ~/.local/bin/uv sync --frozen

      - name: uv contracts (only if pyproject exists)
        if: steps.python-project.outputs.present == 'true'
        shell: sh
        run: |
          set -eu
          if (set -o pipefail) 2>/dev/null; then
            set -o pipefail
          fi
          if [ -f uv.lock ]; then
            echo "OK: uv.lock present"
          else
            echo "::error::uv.lock missing (pyproject.toml present)"
            exit 1
          fi
          export PATH="$HOME/.local/bin:$PATH"
          "$HOME/.local/bin/uv" --version
          echo "Running 'uv sync --frozen' to verify frozen installs..."
          "$HOME/.local/bin/uv" sync --frozen
          echo "uv contracts satisfied âœ…"

      - name: Rust manifest check
        shell: sh
        run: |
          set -eu
          if (set -o pipefail) 2>/dev/null; then
            set -o pipefail
          fi
          if [ -f Cargo.toml ]; then
            rustup toolchain install stable --profile minimal
            cargo metadata --no-deps >/dev/null
          else
            echo "No Cargo.toml present â€“ skipping."
          fi

      - name: Done
        shell: sh
        run: echo "wgx-guard passed âœ…"
```

