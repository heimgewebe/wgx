### ðŸ“„ scripts/gen-cli-docs.sh

**GrÃ¶ÃŸe:** 2 KB | **md5:** `fb209069c2bcc717a00db54561f9e91c`

```bash
#!/usr/bin/env bash
set -euo pipefail

export LC_ALL=C
export LANG=C

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
repo_root="$(cd "${script_dir}/.." && pwd)"
cd "$repo_root"

out_file="docs/cli.md"

mkdir -p "$(dirname "$out_file")"

tmp_file="$(mktemp)"
trap 'rm -f "$tmp_file"' EXIT

if ! top_help=$(./wgx --help 2>&1); then
  echo "Failed to capture top-level help output" >&2
  exit 1
fi

mapfile -t commands < <(./wgx --list | grep -v '^[[:space:]]*$' | sort -u)

{
  echo "# wgx CLI Reference"
  echo
  echo "> Generated by \`scripts/gen-cli-docs.sh\`. Do not edit manually."
  echo
  echo "## Global usage"
  echo
  echo '```'
  printf '%s\n' "$top_help"
  echo '```'
  echo
  echo "## Commands"
  echo
} >"$tmp_file"

for cmd in "${commands[@]}"; do
  echo "### ${cmd}" >>"$tmp_file"
  echo >>"$tmp_file"

  cmd_help=""
  exit_code=0
  # Try common help flags and the `help <cmd>` fallback
  if ! cmd_help=$(./wgx "$cmd" --help 2>&1); then
    exit_code=$?
    if ! cmd_help=$(./wgx "$cmd" -h 2>&1); then
      exit_code=$?
      if ! cmd_help=$(./wgx help "$cmd" 2>&1); then
        exit_code=$?
      else
        exit_code=0
      fi
    else
      exit_code=0
    fi
  fi

  has_structured_help=0
  saw_general_help=0
  if [[ $exit_code -eq 0 ]]; then
    if printf '%s\n' "$cmd_help" | grep -qi '^usage'; then
      if [[ "$cmd" == "help" ]] || [[ "$cmd_help" != "$top_help" ]]; then
        has_structured_help=1
      else
        saw_general_help=1
        cmd_help=""
      fi
    fi
  fi

  if (( has_structured_help )); then
    echo '```' >>"$tmp_file"
    printf '%s\n' "$cmd_help" >>"$tmp_file"
    echo '```' >>"$tmp_file"
  else
    if (( saw_general_help )); then
      echo "_Command does not provide structured --help output._" >>"$tmp_file"
    elif [[ -z "$cmd_help" && $exit_code -eq 0 ]]; then
      echo "_No dedicated --help output available._" >>"$tmp_file"
    elif [[ $exit_code -eq 0 ]]; then
      echo "_Command does not provide structured --help output._" >>"$tmp_file"
    else
      echo "_Failed to capture --help output (exit ${exit_code})._" >>"$tmp_file"
      if [[ -n "$cmd_help" ]]; then
        echo >>"$tmp_file"
        echo '```' >>"$tmp_file"
        printf '%s\n' "$cmd_help" >>"$tmp_file"
        echo '```' >>"$tmp_file"
      fi
    fi
  fi

  echo >>"$tmp_file"
done

mv "$tmp_file" "$out_file"
```

### ðŸ“„ scripts/gen-readiness.sh

**GrÃ¶ÃŸe:** 4 KB | **md5:** `c936182b101c965f4a6e2a00140de0d6`

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$REPO_DIR"

if ! command -v python3 >/dev/null 2>&1; then
  echo "::notice::python3 not found - skipping readiness generation"
  exit 0
fi

ARTIFACT_DIR="$REPO_DIR/artifacts"
mkdir -p "$ARTIFACT_DIR"

read -r summary_count average < <(python3 - "$REPO_DIR" "$ARTIFACT_DIR" <<'PY'
import json
import time
import sys
from pathlib import Path

repo = Path(sys.argv[1])
artifact_dir = Path(sys.argv[2])
modules_dir = repo / "modules"
cmd_dir = repo / "cmd"
docs_dir = repo / "docs"
tests_dir = repo / "tests"

names = set()
if modules_dir.is_dir():
    names.update(path.stem for path in modules_dir.glob("*.bash"))
if cmd_dir.is_dir():
    names.update(path.stem for path in cmd_dir.glob("*.bash"))

modules = sorted(names)

def iter_files(root: Path):
    if not root.exists():
        return
    for path in root.rglob("*"):
        if path.is_file():
            yield path

def count_matches(root: Path, token: str, *, docs=False):
    token_lower = token.lower()
    total = 0
    for path in iter_files(root):
        stem = path.stem.lower()
        name = path.name.lower()
        if docs and path.suffix.lower() not in {".md", ".rst", ".txt"}:
            continue
        if token_lower in stem or token_lower in name:
            total += 1
    return total

rows = []
summary_score = 0
for name in modules:
    tests = count_matches(tests_dir, name)
    docs = count_matches(docs_dir, name, docs=True)
    cli = (cmd_dir / f"{name}.bash").is_file()
    score = (1 if tests > 0 else 0) + (1 if cli else 0) + (1 if docs > 0 else 0)
    if score == 3:
        status = "ready"
    elif score == 2:
        status = "progress"
    elif score == 1:
        status = "partial"
    else:
        status = "seed"
    coverage = int(round(score * 100 / 3))
    summary_score += score
    rows.append({
        "module": name,
        "status": status,
        "tests": tests,
        "cli": cli,
        "docs": docs,
        "coverage": coverage,
    })

summary_count = len(rows)
average = int(round((summary_score * 100 / (summary_count * 3)) if summary_count else 0))

data = {
    "generated_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    "modules": rows,
    "summary": {"count": summary_count, "average_completion": average},
}

(artifact_dir / "readiness.json").write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")

lines = [
    "| Module | Status | Tests | CLI | Docs | Coverage |",
    "| --- | --- | --- | --- | --- | --- |",
]
if rows:
    for row in rows:
        lines.append(f"| {row['module']} | {row['status']} | {row['tests']} | {'âœ…' if row['cli'] else 'â€”'} | {row['docs']} | {row['coverage']}% |")
else:
    lines.append("| _none_ | â€” | 0 | â€” | 0 | 0% |")
(artifact_dir / "readiness-table.md").write_text("\n".join(lines) + "\n", encoding="utf-8")

color = "#4c1"
if average < 40:
    color = "#e05d44"
elif average < 70:
    color = "#dfb317"

badge = f"""<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"190\" height=\"20\" role=\"img\" aria-label=\"WGX Readiness: {average}%\">
  <linearGradient id=\"smooth\" x2=\"0\" y2=\"100%\">
    <stop offset=\"0\" stop-color=\"#bbb\" stop-opacity=\".1\"/>
    <stop offset=\"1\" stop-opacity=\".1\"/>
  </linearGradient>
  <mask id=\"round\">
    <rect width=\"190\" height=\"20\" rx=\"3\" fill=\"#fff\"/>
  </mask>
  <g mask=\"url(#round)\">
    <rect width=\"120\" height=\"20\" fill=\"#555\"/>
    <rect x=\"120\" width=\"70\" height=\"20\" fill=\"{color}\"/>
    <rect width=\"190\" height=\"20\" fill=\"url(#smooth)\"/>
  </g>
  <g aria-hidden=\"true\" fill=\"#fff\" text-anchor=\"middle\" font-family=\"Verdana,DejaVu Sans,sans-serif\" text-rendering=\"geometricPrecision\" font-size=\"110\">
    <text x=\"600\" y=\"140\" transform=\"scale(.1)\" fill=\"#fff\">WGX Readiness</text>
    <text x=\"1530\" y=\"140\" transform=\"scale(.1)\" fill=\"#fff\">{average}%</text>
  </g>
</svg>
"""
(artifact_dir / "readiness-badge.svg").write_text(badge, encoding="utf-8")

print(summary_count, average)
PY
)

if [[ -s "$ARTIFACT_DIR/readiness.json" ]]; then
  echo "Readiness matrix generated at artifacts/readiness.json (modules: $summary_count, avg: ${average}%)."
else
  echo "[readiness] ::warning:: Failed to produce readiness.json" >&2
fi
```

### ðŸ“„ scripts/wgx-metrics-snapshot.sh

**GrÃ¶ÃŸe:** 2 KB | **md5:** `cb3c1acab6ee0433d149f619a8e6dcbb`

```bash
#!/usr/bin/env bash

set -e
set -u

if ! set -o pipefail 2>/dev/null; then
  if [[ ${WGX_DEBUG:-0} != 0 ]]; then
    echo "wgx-metrics-snapshot: 'pipefail' wird nicht unterstÃ¼tzt; fahre ohne fort." >&2
  fi
fi

print_json=0
output_path=${WGX_METRICS_OUTPUT:-metrics.json}

usage() {
  cat <<'EOF'
wgx-metrics-snapshot.sh [--json] [--output PATH]

Erzeugt eine metrics.json gemÃ¤ÃŸ contracts-v1 (ts, host, updates, backup, drift).

  --json           JSON zusÃ¤tzlich zur Datei auf STDOUT ausgeben
  --output PATH    Ziel-Datei (Standard: metrics.json oder WGX_METRICS_OUTPUT)
EOF
}

while ((${#})); do
  case "$1" in
  --json)
    print_json=1
    ;;
  --output)
    if (($# < 2)); then
      echo "--output erwartet einen Pfad" >&2
      usage >&2
      exit 1
    fi
    output_path=$2
    shift
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  *)
    echo "Unbekannte Option: $1" >&2
    usage >&2
    exit 1
    ;;
  esac
  shift
done

if [[ -z ${output_path} ]]; then
  echo "Der Ausgabe-Pfad darf nicht leer sein" >&2
  exit 1
fi

output_dir=$(dirname "$output_path")
if [[ ! -d $output_dir ]]; then
  if ! mkdir -p "$output_dir"; then
    echo "Konnte Ausgabe-Verzeichnis '$output_dir' nicht anlegen" >&2
    exit 1
  fi
fi

ts=$(date +%s)
host=$(hostname)

# Updates (Platzhalter â€“ OS-spezifisch spÃ¤ter ersetzen)
updates_os=${UPDATES_OS:-0}
updates_pkg=${UPDATES_PKG:-0}
updates_flatpak=${UPDATES_FLATPAK:-0}

# Backup-Status (Platzhalter)
if date -d "yesterday" +%F >/dev/null 2>&1; then
  last_ok=$(date -d "yesterday" +%F)
else
  last_ok=$(date -v-1d +%F) # BSD/macOS
fi
age_days=${BACKUP_AGE_DAYS:-1}

# Template-Drift (Platzhalter)
drift_templates=${DRIFT_TEMPLATES:-0}

json=$(jq -n \
  --arg host "$host" \
  --arg last_ok "$last_ok" \
  --argjson ts "$ts" \
  --argjson uos "$updates_os" \
  --argjson upkg "$updates_pkg" \
  --argjson ufp "$updates_flatpak" \
  --argjson age "$age_days" \
  --argjson drift "$drift_templates" \
  '{
    ts: $ts,
    host: $host,
    updates: { os: $uos, pkg: $upkg, flatpak: $ufp },
    backup: { last_ok: $last_ok, age_days: $age },
    drift: { templates: $drift }
  }')

printf '%s\n' "$json" >"$output_path"

if ((print_json != 0)); then
  printf '%s\n' "$json"
fi
```

