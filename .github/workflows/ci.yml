name: CI (smart PR)

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  merge_group: {}
  workflow_dispatch: {}

permissions:
  id-token: write
  pull-requests: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      shell: ${{ steps.filter.outputs.shell }}
      tests: ${{ steps.filter.outputs.tests }}
      docs: ${{ steps.filter.outputs.docs }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # Pin to SHA for security - v3.0.2
      - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36
        id: filter
        with:
          filters: |
            shell:
              - 'wgx'
              - '**/*.sh'
              - '**/*.bash'
            tests:
              - 'tests/**/*.bats'
              - 'tests/**/*.sh'
            docs:
              - '**/*.md'
              - 'docs/**'

  lint_shell:
    name: Shell lint (shfmt + shellcheck)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.shell == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci') ||
          contains(github.event.pull_request.labels.*.name, 'lint')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Find changed shell files
        id: shell_files
        env:
          FORCE_FULL: ${{ github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'full-ci') || contains(github.event.pull_request.labels.*.name, 'lint') }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
        run: |
          set -euo pipefail
          base="$PR_BASE_SHA"
          head="${GITHUB_SHA}"
          declare -a candidates=()
          if [[ "$FORCE_FULL" == 'true' ]]; then
            mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
          elif [[ -n "$base" ]]; then
            if git fetch --no-tags --depth=50 origin "$base"; then
              mapfile -t candidates < <(git diff --name-only "$base" "$head" 2>/dev/null || true)
            else
              echo "git fetch failed; falling back to full shell file list" >&2
              mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
            fi
          else
            mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
          fi

          declare -a shell_files=()
          for file in "${candidates[@]}"; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              case "$file" in
                *.sh|*.bash|wgx)
                  shell_files+=("$file")
                  ;;
              esac
            fi
          done

          {
            echo 'files<<EOF'
            printf '%s\n' "${shell_files[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - name: Install shell tooling
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends shellcheck shfmt jq
      - name: bash -n (syntax check)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh --per-file "No shell files to check." bash -n <<-'EOF'
          ${{ steps.shell_files.outputs.files }}
          EOF
      - name: shfmt (check)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No shell files to format." shfmt -d <<-'EOF'
          ${{ steps.shell_files.outputs.files }}
          EOF
      - name: shellcheck
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No shell files to lint." shellcheck -x -S style <<-'EOF'
          ${{ steps.shell_files.outputs.files }}
          EOF

  bats_tests:
    name: Bats tests
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.shell == 'true' ||
          needs.changes.outputs.tests == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci') ||
          contains(github.event.pull_request.labels.*.name, 'tests') ||
          contains(github.event.pull_request.labels.*.name, 'bats')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install test dependencies
        run: |
          # python3-yaml: stellt das Python-Paket `pyyaml` bereit,
          # das von WGX für das Parsen von `.wgx/profile.yml` genutzt wird.
          # Ohne diese Abhängigkeit schlagen Profil-Tests fehl.
          sudo apt-get update -y
          sudo apt-get install -y python3-yaml
          # jsonschema: required for heimgeist insight validation
          python3 -m pip install jsonschema
      - name: Run bats test suites
        uses: ./.github/actions/run-bats

  docs_lint:
    name: Docs lint (Markdown + Links)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        (
          needs.changes.outputs.docs == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    env:
      # Required by Vale install script; must be job-level so scripts can assert presence.
      VALE_VERSION: v2.27.0
    steps:
      - uses: actions/checkout@v4
      - name: Find changed docs and script files
        id: changed_docs
        env:
          FORCE_FULL: ${{ github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'full-ci') }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
        run: |
          set -euo pipefail
          base="$PR_BASE_SHA"
          head="${GITHUB_SHA}"
          declare -a candidates=()
          if [[ "$FORCE_FULL" == 'true' ]]; then
            mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
          elif [[ -n "$base" ]]; then
            if git fetch --no-tags --depth=50 origin "$base"; then
              mapfile -t candidates < <(git diff --name-only "$base" "$head" -- '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
            else
              echo "git fetch failed; falling back to full docs file list" >&2
              mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
            fi
          else
            mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
          fi

          declare -a markdown_files=()
          declare -a vale_files=()
          for file in "${candidates[@]}"; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              case "$file" in
                *.md|*.mdx)
                  markdown_files+=("$file")
                  vale_files+=("$file")
                  ;;
                *.sh|*.bash)
                  vale_files+=("$file")
                  ;;
              esac
            fi
          done

          {
            echo 'markdown_files<<EOF'
            printf '%s\n' "${markdown_files[@]}"
            echo 'EOF'
            echo 'vale_files<<EOF'
            printf '%s\n' "${vale_files[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install Vale
        env:
          VALE_VERSION: ${{ env.VALE_VERSION }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          set -x  # Enable debug output to see API responses
          owner="errata-ai"
          repo="vale"
          version="${VALE_VERSION:-latest}"
          release_json=""
          
          # Validate version variable is populated (owner/repo are hardcoded literals)
          if [[ -z "${version}" ]]; then
            echo "::error::Missing required variable (version)" >&2
            exit 1
          fi

          # Use authenticated GitHub API requests to avoid low rate limits
          accept_header="Accept: application/vnd.github+json"
          api_ver_header="X-GitHub-Api-Version: 2022-11-28"

          curl_headers=(
            -H "$accept_header"
            -H "$api_ver_header"
          )

          if [[ -n "${GITHUB_TOKEN:-}" ]]; then
            curl_headers+=(
              -H "Authorization: Bearer ${GITHUB_TOKEN}"
            )
          fi

          # Define function to fetch release safely
          fetch_release() {
            local url="$1"
            local tmp_body
            tmp_body=$(mktemp)
            local status_code

            # Use curl -w to capture status code cleanly, avoid awk on full response
            if ! status_code=$(curl --retry 5 --retry-all-errors -fsSL \
                "${curl_headers[@]}" \
                -w "%{http_code}" -o "$tmp_body" \
                "$url"); then
               echo "::warning::curl failed for $url"
               rm -f "$tmp_body"
               return 1
            fi
            
            if [[ "$status_code" != "200" ]]; then
              echo "::warning::HTTP $status_code for $url"
              rm -f "$tmp_body"
              return 1
            fi

            cat "$tmp_body"
            rm -f "$tmp_body"
          }

          if [[ -n "${version}" && "${version}" != "latest" ]]; then
            url="https://api.github.com/repos/${owner}/${repo}/releases/tags/${version}"
            if ! release_json=$(fetch_release "$url"); then
              echo "Unable to fetch release metadata for ${version}; falling back to latest" >&2
              release_json=""
            fi
          fi

          if [[ -z "${release_json}" ]]; then
            echo "Fetching latest Vale release from GitHub API..." >&2
            url="https://api.github.com/repos/${owner}/${repo}/releases/latest"
            if ! release_json=$(fetch_release "$url"); then
              echo "::error::Failed to fetch release data (API error)" >&2
              exit 1
            fi
            
            if [[ -z "${release_json}" ]]; then
              echo "::error::Failed to fetch release data (empty response)" >&2
              exit 1
            fi
          fi

          # Always extract the actual version from the release JSON to ensure it's set correctly
          if ! version=$(printf '%s' "${release_json}" | jq -r '.tag_name'); then
            echo "::error::Failed to extract version from release metadata" >&2
            exit 1
          fi
          
          if [[ -z "${version}" || "${version}" == "null" ]]; then
            echo "::error::Missing required version in release metadata" >&2
            exit 1
          fi

          echo "Using Vale version: ${version}" >&2

          # Find Linux asset (prefer Linux_64-bit.tar.gz, then Linux_amd64.tar.gz)
          asset_name=""
          asset_url=""
          
          for suffix in "Linux_64-bit.tar.gz" "Linux_amd64.tar.gz"; do
            read -r asset_name asset_url < <(printf '%s' "${release_json}" | jq -r --arg suffix "$suffix" '
              ([.assets[] | select(.name | endswith($suffix))][0] // {name: "", browser_download_url: ""}) | "\(.name) \(.browser_download_url)"
            ')
            
            if [[ -n "${asset_name}" && -n "${asset_url}" ]]; then
              break
            fi
          done
          
          if [[ -z "${asset_name}" || -z "${asset_url}" ]]; then
            echo "::error::No suitable Linux tarball found in release assets" >&2
            available=$(printf '%s' "${release_json}" | jq -r '.assets[].name' | paste -sd ',' -)
            echo "Available assets: ${available}" >&2
            exit 1
          fi

          # Find checksums file
          checksums_url=$(printf '%s' "${release_json}" | jq -r '
            ([.assets[] | select(.name | endswith("checksums.txt"))][0] // {browser_download_url: ""}) | .browser_download_url
          ')
          
          # Validate checksums URL
          if [[ -z "${checksums_url}" ]]; then
            echo "::error::Checksums file not found in release assets" >&2
            exit 1
          fi

          echo "Downloading Vale tarball: ${asset_url}" >&2
          
          # Robust download function with exponential backoff
          download_with_retry() {
            local url="$1"
            local output="$2"
            local max_attempts=6
            local attempt=1
            local wait_time=3

            while [ $attempt -le $max_attempts ]; do
              echo "Download attempt $attempt/$max_attempts: $url" >&2
              
              # Capture HTTP status code
              local http_code
              http_code=$(curl -w '%{http_code}' -o "$output" -fsSL \
                --retry 3 --retry-all-errors \
                "${curl_headers[@]}" \
                "$url" 2>/dev/null || echo "000")
              
              if [[ "$http_code" == "200" ]] && [[ -s "$output" ]]; then
                echo "Download successful on attempt $attempt" >&2
                return 0
              elif [[ "$http_code" == "503" ]]; then
                echo "::warning::HTTP 503 Service Unavailable (attempt $attempt/$max_attempts)" >&2
                rm -f "$output"
              elif [[ "$http_code" == "000" ]]; then
                echo "::warning::Download failed - network error (attempt $attempt/$max_attempts)" >&2
                rm -f "$output"
              else
                echo "::warning::HTTP $http_code (attempt $attempt/$max_attempts)" >&2
                rm -f "$output"
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                echo "Waiting ${wait_time}s before retry..." >&2
                sleep $wait_time
                wait_time=$((wait_time * 2))
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "::error::Download failed after $max_attempts attempts: $url" >&2
            return 1
          }
          
          download_with_retry "${asset_url}" vale.tar.gz || exit 1
          
          # Verify downloaded tarball is non-empty
          if [[ ! -s vale.tar.gz ]]; then
            echo "::error::Downloaded vale.tar.gz is empty" >&2
            exit 1
          fi

          echo "Downloading checksums: ${checksums_url}" >&2
          download_with_retry "${checksums_url}" checksums.txt || exit 1
          
          # Verify downloaded checksums file is non-empty
          if [[ ! -s checksums.txt ]]; then
            echo "::error::Downloaded checksums.txt is empty" >&2
            exit 1
          fi

          EXPECTED_SHA256=$(awk -v file="${asset_name}" '$2 == file {print $1; exit}' checksums.txt)
          if [[ -z "${EXPECTED_SHA256:-}" ]]; then
            echo "::error::Unable to determine expected checksum for ${asset_name}" >&2
            echo "Available checksums:" >&2
            cat checksums.txt >&2
            exit 1
          fi

          echo "Expected SHA256: ${EXPECTED_SHA256}" >&2

          ACTUAL_SHA256=$(sha256sum vale.tar.gz | awk '{print $1}')
          if [[ "${EXPECTED_SHA256}" != "${ACTUAL_SHA256}" ]]; then
            echo "::error::Checksum mismatch for vale.tar.gz" >&2
            echo "Expected: ${EXPECTED_SHA256}" >&2
            echo "Actual:   ${ACTUAL_SHA256}" >&2
            exit 1
          fi

          tar -xzf vale.tar.gz
          test -f vale && echo "vale binary extracted" || (echo "vale missing" && exit 1)
          sudo install -m 0755 vale /usr/local/bin/vale
          echo "Installed Vale ${version} (${asset_name})"
          vale --version
          rm -f vale vale.tar.gz checksums.txt
      - name: Markdownlint (changed only)
        run: |
          set -euo pipefail
          npm i -g markdownlint-cli2@0.14.0
          ./etc/ci/run-with-files.sh "No Markdown files to lint." markdownlint-cli2 <<-'EOF'
          ${{ steps.changed_docs.outputs.markdown_files }}
          EOF
      - name: Vale lint (changed only)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No files for Vale." vale --minAlertLevel=warning <<-'EOF'
          ${{ steps.changed_docs.outputs.vale_files }}
          EOF
      - name: Check Markdown links
        if: steps.changed_docs.outputs.markdown_files != ''
        run: |
          set -euo pipefail
          npm i -g markdown-link-check
          # Check if there are files before running markdown-link-check
          if [ -n "${{ steps.changed_docs.outputs.markdown_files }}" ]; then
            ./etc/ci/run-with-files.sh "No markdown files." markdown-link-check --config .github/markdown-link-check.json <<-'EOF'
          ${{ steps.changed_docs.outputs.markdown_files }}
          EOF
          else
            echo "No markdown files to check."
          fi

  profile_contracts:
    name: Profile contracts
    needs: changes
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'merge_group' ||
      (
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'full-ci')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        repo:
          - https://github.com/heimgewebe/weltgewebe
          - https://github.com/heimgewebe/hausKI
          # ggf. weitere Repos ergänzen
    steps:
      - uses: actions/checkout@v4
      - name: Configure git safe.directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"
      - name: Validate ${{ matrix.repo }}
        env:
          GIT_ASKPASS: /bin/true
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="${{ matrix.repo }}"
          name="${repo##*/}"
          target="$repo"
          if [[ "$repo" == https://github.com/* && -n "${GH_TOKEN:-}" ]]; then
            target="https://x-access-token:${GH_TOKEN}@github.com/${repo#https://github.com/}"
          fi
          ./wgx validate --json "$target" --out "validate_${name}.json"
      - name: Upload JSON results
        uses: actions/upload-artifact@v4
        with:
          name: profile-contracts-json
          path: validate_*.json
